package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"log"

	"github.com/imijanur/graphql-grpc-server/graph/model"
	"github.com/imijanur/graphql-grpc-server/internal"
	pb "github.com/imijanur/graphql-grpc-server/proto"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, email string, status string) (*model.User, error) {
	client := internal.GetUserServiceClient()
	req := &pb.CreateUserRequest{
		Email:  email,
		Status: status,
	}

	res, err := client.CreateUser(ctx, req)
	if err != nil {
		return nil, err
	}

	user := &model.User{
		ID:         res.User.Id,
		Email:      res.User.Email,
		Status:     res.User.Status,
		CreatedAt:  res.User.CreatedAt,
		ModifiedAt: res.User.UpdatedAt,
	}

	return user, nil
}

// CreateContact is the resolver for the createContact field.
func (r *mutationResolver) CreateContact(ctx context.Context, userID string, firstName string, lastName string, phone string) (*model.UserContact, error) {
	// Implement your logic to create a user contact here
	// For example, you might save the user contact to a database and return the created user contact
	userContact := &model.UserContact{
		FirstName: firstName,
		LastName:  lastName,
		Phone:     phone,
		UserID:    userID,
	}

	// insert user contact to the database
	client := internal.GetUserServiceClient()
	req := &pb.CreateContactRequest{
		UserId:    userID,
		FirstName: firstName,
		LastName:  lastName,
		Phone:     phone,
	}

	res, err := client.CreateContact(ctx, req)
	if err != nil {
		return nil, err
	}

	userContact.ID = res.Contact.Id

	return userContact, nil
}

// CreateUserAddress is the resolver for the createUserAddress field.
func (r *mutationResolver) CreateUserAddress(ctx context.Context, userID string, name string, prefix *string, streetAddress1 string, streetAddress2 *string, city string, state string, zipCode string) (*model.UserAddress, error) {
	// Implement your logic to create a user address here
	// For example, you might save the user address to a database and return the created user address
	userAddress := &model.UserAddress{
		Name:           name,
		Prefix:         prefix,
		StreetAddress1: streetAddress1,
		StreetAddress2: streetAddress2,
		City:           city,
		State:          state,
		ZipCode:        zipCode,
		UserID:         userID,
	}

	// insert user address to the database
	client := internal.GetUserServiceClient()
	req := &pb.CreateAddressRequest{
		UserId:         userID,
		Name:           name,
		Prefix:         *prefix,
		StreetAddress1: streetAddress1,
		StreetAddress2: *streetAddress2,
		City:           city,
		State:          state,
		ZipCode:        zipCode,
	}

	res, err := client.CreateAddress(ctx, req)
	if err != nil {
		return nil, err
	}

	userAddress.ID = res.Address.Id

	return userAddress, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, limit *int, offset *int) ([]*model.User, error) {
	client := internal.GetUserServiceClient()
	if limit == nil {
		defaultLimit := 10
		limit = &defaultLimit
	}
	if offset == nil {
		defaultOffset := 0
		offset = &defaultOffset
	}
	req := &pb.GetUsersRequest{
		Limit:  int32(*limit),
		Offset: int32(*offset),
	}

	res, err := client.GetUsers(ctx, req)
	if err != nil {
		log.Printf("Error: %v", err.Error())
		return nil, err
	}

	var users []*model.User
	for _, u := range res.Users {
		user := &model.User{
			ID:     u.User.Id,
			Email:  u.User.Email,
			Status: u.User.Status,
		}

		contact := &model.UserContact{
			ID:        u.Contact.Id,
			FirstName: u.Contact.FirstName,
			LastName:  u.Contact.LastName,
			Phone:     u.Contact.Phone,
			UserID:    u.Contact.UserId,
		}

		user.Contact = contact

		var addresses []*model.UserAddress

		for _, a := range u.Addresses {
			address := &model.UserAddress{
				ID:             a.Id,
				Name:           a.Name,
				Prefix:         &a.Prefix,
				StreetAddress1: a.StreetAddress_1,
				StreetAddress2: &a.StreetAddress_2,
				City:           a.City,
				State:          a.State,
				ZipCode:        a.ZipCode,
				UserID:         a.UserId,
			}
			addresses = append(addresses, address)
		}

		user.Addresses = addresses

		users = append(users, user)
	}

	return users, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
